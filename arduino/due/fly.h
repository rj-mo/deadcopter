// 2020-12-25 18:45:00.655180

#ifndef fly.h
#define fly.h

#include <Arduino.h>
#include <math.h>
#include <MatrixMath.h>
#include "imu.h"
#include "receiver.h"

#define Ad [[ 1.00000000e+00  0.00000000e+00  0.00000000e+00  2.10084034e-03
   0.00000000e+00  0.00000000e+00  1.17469529e-05  0.00000000e+00
   0.00000000e+00]
 [ 0.00000000e+00  1.00000000e+00  0.00000000e+00  0.00000000e+00
   2.10084034e-03  0.00000000e+00  0.00000000e+00  1.10905055e-05
   0.00000000e+00]
 [ 0.00000000e+00  0.00000000e+00  1.00000000e+00  0.00000000e+00
   0.00000000e+00  2.10084034e-03  0.00000000e+00  0.00000000e+00
  -7.08490452e-06]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
   0.00000000e+00  0.00000000e+00  1.09637883e-02  0.00000000e+00
   0.00000000e+00]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
   1.00000000e+00  0.00000000e+00  0.00000000e+00  1.03511060e-02
   0.00000000e+00]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
   0.00000000e+00  1.00000000e+00  0.00000000e+00  0.00000000e+00
  -6.61255682e-03]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
   0.00000000e+00  0.00000000e+00  8.86877849e-01  0.00000000e+00
   0.00000000e+00]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
   0.00000000e+00  0.00000000e+00  0.00000000e+00  8.86877849e-01
   0.00000000e+00]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
   0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
   8.86877849e-01]]  // discrete A matrix
#define Bd [[5.53298612e-05 0.00000000e+00 0.00000000e+00]
 [0.00000000e+00 5.22378983e-05 0.00000000e+00]
 [0.00000000e+00 0.00000000e+00 8.99831983e-04]
 [7.82347063e-02 0.00000000e+00 0.00000000e+00]
 [0.00000000e+00 7.38627668e-02 0.00000000e+00]
 [0.00000000e+00 0.00000000e+00 8.41223712e-01]
 [1.31843868e+01 0.00000000e+00 0.00000000e+00]
 [0.00000000e+00 1.31843868e+01 0.00000000e+00]
 [0.00000000e+00 0.00000000e+00 1.31843868e+01]]  // discrete B matrix
#define Cd [[1. 0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 1. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 1. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 1. 0. 0. 0.]]  // discrete C matrix
#define K_x [[-1.01217438e+02 -0.00000000e+00 -0.00000000e+00 -1.78119824e+00
  -0.00000000e+00 -0.00000000e+00 -7.69350998e-02 -0.00000000e+00
  -0.00000000e+00]
 [-0.00000000e+00 -1.01661441e+02 -0.00000000e+00 -0.00000000e+00
  -1.83350638e+00 -0.00000000e+00 -0.00000000e+00 -7.66691353e-02
  -0.00000000e+00]
 [-0.00000000e+00 -0.00000000e+00 -1.01777465e+02 -0.00000000e+00
  -0.00000000e+00 -1.27427509e+00 -0.00000000e+00 -0.00000000e+00
   6.73803082e-03]]  // LQR gain for state control
#define K_z [[ 2.08633533e-01 -0.00000000e+00 -0.00000000e+00  3.83308332e-06
  -0.00000000e+00 -0.00000000e+00]
 [-0.00000000e+00  2.09456828e-01 -0.00000000e+00 -0.00000000e+00
   3.58623084e-06 -0.00000000e+00]
 [-0.00000000e+00 -0.00000000e+00  2.10885753e-01 -0.00000000e+00
  -0.00000000e+00  3.60794168e-12]]  // LQR gain for integral action
#define L [[-6.18041474e-01 -0.00000000e+00 -0.00000000e+00 -1.58736062e-03
  -0.00000000e+00 -0.00000000e+00]
 [-0.00000000e+00 -6.18041473e-01 -0.00000000e+00 -0.00000000e+00
  -1.58725628e-03 -0.00000000e+00]
 [-0.00000000e+00 -0.00000000e+00 -6.18041467e-01 -0.00000000e+00
  -0.00000000e+00 -1.58674863e-03]
 [-1.67375157e-03 -0.00000000e+00 -0.00000000e+00 -6.56353382e-01
  -0.00000000e+00 -0.00000000e+00]
 [-0.00000000e+00 -1.67314940e-03 -0.00000000e+00 -0.00000000e+00
  -6.56300753e-01 -0.00000000e+00]
 [-0.00000000e+00 -0.00000000e+00 -1.67021931e-03 -0.00000000e+00
  -0.00000000e+00 -6.56044742e-01]
 [-2.81172513e-04 -0.00000000e+00 -0.00000000e+00 -2.49486407e-02
  -0.00000000e+00 -0.00000000e+00]
 [-0.00000000e+00 -2.65548314e-04 -0.00000000e+00 -0.00000000e+00
  -2.35610436e-02 -0.00000000e+00]
 [-0.00000000e+00 -0.00000000e+00  1.69914230e-04 -0.00000000e+00
  -0.00000000e+00  1.50719204e-02]]  // Kalman filter gain for minimising observation error
#define G [[ 1.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
   0.00000000e+00  0.00000000e+00]
 [ 0.00000000e+00  1.00000000e+00  0.00000000e+00  0.00000000e+00
   0.00000000e+00  0.00000000e+00]
 [ 0.00000000e+00  0.00000000e+00  1.00000000e+00  0.00000000e+00
   0.00000000e+00  0.00000000e+00]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  9.99995586e-01
  -3.10027686e-23  1.97284625e-22]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00 -1.28749008e-19
   9.99995586e-01  1.88716618e-16]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  -8.68919801e-18  9.99995586e-01]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00 -1.89666537e-04
   1.19348975e-15 -7.71154780e-15]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  1.71446727e-17
  -2.00892654e-04 -1.26010313e-14]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00 -5.87669361e-16
  -1.78079051e-13 -3.64635015e-03]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00 -1.62701602e-06
  -1.11022302e-16 -6.04519300e-17]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  1.48921997e-19
  -1.72335434e-06 -1.11022302e-16]
 [ 0.00000000e+00  0.00000000e+00  0.00000000e+00 -5.04204124e-18
  -1.49010076e-15 -3.12859113e-05]]  // for calculating new equilibrium state and control action

class Fly {
    private:
    int u[3];  // control action on quadcopter (u_x, u_y, u_z)
    float r[6];  // control input from receiver (q1, q2, q3, 0, 0, 0)
    float z[6];  // storing integral values
    float y[6];  // IMU values
    float y_hat[6];  // observed IMU values
    float x_hat[9];  // observed state

    public:
    Fly();

}

/*--------------------------------------------------------------------------------------------------------------------*/

Fly::Fly() {
    u = (0, 0, 0);
    x_hat = (0, 0, 0, 0, 0, 0, 0, 0, 0);
    z = (0, 0, 0, 0, 0, 0);
}

void observe_and_control(void) {
    // get imu values
    y = Imu.update_imu_data();

    // get control input from receiver
    phi = Receiver.rx_roll / 2.0f;
    theta = Receiver.rx_pitch / 2.0f;
    psi = Receiver.rx_rudder / 2.0f;
    r[0] = sin(phi)*cos(theta)*cos(psi) - cos(phi)*sin(theta)*sin(psi);
    r[1] = cos(phi)*sin(theta)*cos(psi) + sin(phi)*cos(theta)*sin(psi);
    r[2] = cos(phi)*cos(theta)*sin(psi) - sin(phi)*sin(theta)*cos(psi);

    // observe
    y_hat[0] = Cd[0][0] * x_hat[0];
    y_hat[1] = Cd[1][1] * x_hat[1];
    y_hat[2] = Cd[2][2] * x_hat[2];
    y_hat[3] = Cd[3][3] * x_hat[3];
    y_hat[4] = Cd[4][4] * x_hat[4];
    y_hat[5] = Cd[5][5] * x_hat[5];
    x_hat[0] =

    // control

}

#endif